Index: stf/private/stf-apps/flasher_width.c
===================================================================
RCS file: /home/icecube/cvsroot/stf/private/stf-apps/flasher_width.c,v
retrieving revision 1.4.2.3
diff -u -r1.4.2.3 flasher_width.c
--- stf/private/stf-apps/flasher_width.c	14 Apr 2005 00:13:19 -0000	1.4.2.3
+++ stf/private/stf-apps/flasher_width.c	1 Jul 2005 14:22:15 -0000
@@ -27,15 +27,17 @@
 #define N_LEDS                    12
 
 /* Maximum pulse width setting */
-/* Actual maximum is 255, but we max out the ATWD window before that */
-/* because we use such a high sampling speed */
-#define FB_MAX_WIDTH             220
+#define FB_MAX_WIDTH             255
 
 /* Pass/fail defines */
 /* Width in ATWD samples here is *approximately* same in ns */
-#define FB_MIN_ATWD_WIDTH         10
+#define FB_MIN_ATWD_WIDTH         20
 #define FB_MAX_ATWD_WIDTH         95
 
+/* Early abort pulse width measurement */
+/* If we measure this width, we can stop */
+#define FB_ATWD_WIDTH_DONE       100
+
 /* Rounding convert to int */
 #define round(x) ((x)>=0?(int)((x)+0.5):(int)((x)-0.5))
 
@@ -58,6 +60,7 @@
                            unsigned int * reset_time_us,
                            unsigned int * missing_width,
                            unsigned int * failing_led,
+                           unsigned int * failing_led_cnt,
                            unsigned int * led_avg_current
                            ) {
     
@@ -68,8 +71,13 @@
         HAL_FPGA_TEST_TRIGGER_ATWD0 : HAL_FPGA_TEST_TRIGGER_ATWD1;
 
     /* Default return values */
-    *failing_led = *missing_width = 0;
-    *config_time_us = *reset_time_us = *valid_time_us = 0;
+    *failing_led_cnt = *failing_led = *missing_width = 0;
+    *config_time_us = *reset_time_us = *valid_time_us = 0;    
+
+    /* Per-LED fails */
+    int led_fail[N_LEDS];
+    for (i = 0; i < N_LEDS; i++)
+        led_fail[i] = 0;
 
     static char dummy_id[9] = "deadbeef";
     *flasher_id = dummy_id;
@@ -199,7 +207,9 @@
         /* Select which LED current to send from the flasherboard (encoded) */
         hal_FB_select_mux_input(DOM_FB_MUX_LED_1 + led);
 
-        for (w = 0; w <= FB_MAX_WIDTH; w++) {
+        w = 0;
+        int done = 0;
+        while ((w <= FB_MAX_WIDTH) && (!done)) {
 
             #ifdef VERBOSE
             printf("Setting pulse width to %d\n", w);
@@ -332,13 +342,26 @@
             /* Stop flashing */
             hal_FPGA_TEST_stop_FB_flashing();
 
+            /* Check if we've gotten widths wide enough to stop testing */
+            done = (widths[w] >= FB_ATWD_WIDTH_DONE);
+
+            /* Increment width */
+            w++;
+
         } /* End width loop */
 
+        int w_max = w;
+
         /* Check to make sure all widths are covered by some setting */
-        int w_ref, found = 0;
-        for (w_ref = FB_MIN_ATWD_WIDTH; w_ref <= FB_MAX_ATWD_WIDTH; w_ref++) {
-            for (w = 0; w <= FB_MAX_WIDTH; w++) {
+        int w_ref;
+        int found;
+        for (w_ref = 0; w_ref <= FB_MAX_ATWD_WIDTH; w_ref++) {
+            found = 0;
+            for (w = 0; w < w_max; w++) {                
                 if ((int)widths[w] == w_ref) {
+                    #ifdef VERBOSE                   
+                    printf("Found wref %d at index %d\r\n", w_ref, w);
+                    #endif
                     found = 1;
                     break;
                 }
@@ -347,8 +370,16 @@
                 #ifdef VERBOSE
                 printf("Found missing width: led %d, width %d\n",led+1,w_ref);
                 #endif
-                *failing_led = led+1;
-                *missing_width = w_ref;
+                /* Check pass/fail condition */
+                if (w_ref > FB_MIN_ATWD_WIDTH) {
+                    led_fail[led] = 1;
+                }
+                /* Keep track of the largest one for reporting */
+                if (w_ref > *missing_width) {
+                    *missing_width = w_ref;
+                    if (w_ref > FB_MIN_ATWD_WIDTH) 
+                        *failing_led = led+1;
+                }
             }
         }
         
@@ -378,7 +409,14 @@
     #endif
 
     /* Check pass/fail conditions */
-    BOOLEAN passed = (*missing_width > 0) ? FALSE : TRUE;
+    BOOLEAN passed = TRUE;
+    for (led = 0; led < N_LEDS; led++) {
+        *failing_led_cnt += led_fail[led];
+#ifdef VERBOSE
+        printf("LED %d: %s\r\n", (led+1), led_fail[led] ? "failed" : "passed");
+#endif
+        passed &= (led_fail[led] == 0);
+    }
 
     /* Free allocated structures */
     free(atwd_pedestal[3]);
Index: stf/private/stf-apps/flasher_width.xml
===================================================================
RCS file: /home/icecube/cvsroot/stf/private/stf-apps/flasher_width.xml,v
retrieving revision 1.2.2.2
diff -u -r1.2.2.2 flasher_width.xml
--- stf/private/stf-apps/flasher_width.xml	15 Mar 2005 23:00:05 -0000	1.2.2.2
+++ stf/private/stf-apps/flasher_width.xml	1 Jul 2005 14:22:23 -0000
@@ -4,7 +4,7 @@
   <name>flasher_width</name>
   <description>Flasher Board LED Pulse Width Test</description>
 
-  <version major="1" minor="3"/>
+  <version major="1" minor="5"/>
 
   <inputParameter>
     <description>DAC setting for ATWD sampling speed</description>
@@ -99,6 +99,12 @@
   <outputParameter>
     <description>LED With Missing Width Coverage</description>
     <name>failing_led</name>
+	<unsignedInt/>
+  </outputParameter>  
+
+  <outputParameter>
+    <description>Total Number of LEDs Failing Test</description>
+    <name>failing_led_cnt</name>
 	<unsignedInt/>
   </outputParameter>  
     
Index: stf/private/stf-apps/flasher_brightness.xml
===================================================================
RCS file: /home/icecube/cvsroot/stf/private/stf-apps/flasher_brightness.xml,v
retrieving revision 1.2.2.3
diff -u -r1.2.2.3 flasher_brightness.xml
--- stf/private/stf-apps/flasher_brightness.xml	14 Apr 2005 00:11:10 -0000	1.2.2.3
+++ stf/private/stf-apps/flasher_brightness.xml	1 Jul 2005 14:22:33 -0000
@@ -4,7 +4,7 @@
   <name>flasher_brightness</name>
   <description>Flasher Board LED Brightness Test</description>
 
-  <version major="1" minor="4"/>
+  <version major="1" minor="6"/>
 
   <inputParameter>
     <description>DAC setting for ATWD sampling speed</description>
@@ -129,6 +129,12 @@
   <outputParameter>
     <description>LED with Minimum Slope of Brightness Fit</description>
     <name>min_slope_led</name>
+	<unsignedInt/>
+  </outputParameter>  
+
+  <outputParameter>
+    <description>Total Number of LEDs Failing Test</description>
+    <name>failing_led_cnt</name>
 	<unsignedInt/>
   </outputParameter>  
     
Index: stf/private/stf-apps/flasher_brightness.c
===================================================================
RCS file: /home/icecube/cvsroot/stf/private/stf-apps/flasher_brightness.c,v
retrieving revision 1.4.2.4
diff -u -r1.4.2.4 flasher_brightness.c
--- stf/private/stf-apps/flasher_brightness.c	14 Apr 2005 00:11:10 -0000	1.4.2.4
+++ stf/private/stf-apps/flasher_brightness.c	1 Jul 2005 14:22:39 -0000
@@ -35,11 +35,11 @@
 
 /* Pass/fail defines */
 /* Maximum allowed deviation of each point from linear fit */
-#define MAX_ERR_PCT                7
+#define MAX_ERR_PCT               10
 
 /* Minimum current peak in ATWD units at maximum brightness */
-/* About 85% of nominal value of 440 */
-#define MIN_PEAK_MAX_BRIGHT      375 
+/* Nominal value is ~440, but decreases at cold temps */
+#define MIN_PEAK_MAX_BRIGHT      300
 
 /* Minimum slope of linear brightness relationship */
 /* Very loose condition -- nominal slope is 3.0 */
@@ -106,6 +106,7 @@
                                 unsigned int * worst_brightness_led,
                                 unsigned int * min_slope_x_100,
                                 unsigned int * min_slope_led,
+                                unsigned int * failing_led_cnt,
                                 unsigned int * led_avg_current
                              ) {
 
@@ -120,6 +121,7 @@
     *min_peak_brightness_atwd = *worst_brightness_led = 0;
     *config_time_us = *reset_time_us = *valid_time_us = 0;
     *min_slope_x_100 = *min_slope_led = 0;
+    *failing_led_cnt = 0;
 
     static char dummy_id[9] = "deadbeef";
     *flasher_id = dummy_id;
@@ -144,6 +146,11 @@
             return FALSE;
     }
 
+    /* Per-LED fails */
+    int led_fail[N_LEDS];
+    for (i = 0; i < N_LEDS; i++) 
+        led_fail[i] = 0;
+
     /* Peaks in current wavesforms */
     int peaks[N_BRIGHTS];
     int widths[N_BRIGHTS];
@@ -371,7 +378,11 @@
             pred = slope*brights[i] + intercept;
             err_pct = abs(round(((pred - peaks[i]) * 100.0 / pred)));
             
-            /* Record worst error */
+            /* Check linearity error for pass/fail */
+            if (err_pct > MAX_ERR_PCT)
+                led_fail[led] = 1;
+
+            /* Record worst linearity error */
             if (err_pct > *max_current_err_pct) {                
                 *max_current_err_pct = err_pct;
                 *worst_linearity_led = led+1;
@@ -383,6 +394,10 @@
             }
         }      
 
+        /* Check minimum brightness for pass/fail */
+        if (peaks[N_BRIGHTS-1] < MIN_PEAK_MAX_BRIGHT)
+            led_fail[led] = 1;
+
         /* Record minimum brightness at peak setting */
         if ((led == 0) || ((peaks[N_BRIGHTS-1] < *min_peak_brightness_atwd))) {
             *min_peak_brightness_atwd = peaks[N_BRIGHTS-1];
@@ -393,6 +408,10 @@
             #endif
         }
 
+        /* Check slope for pass fail */
+        if (slope < MIN_SLOPE)
+            led_fail[led] = 1;
+
         /* Keep track of minimum slope */
         if ((led == 0) || ((int)(slope*100) < *min_slope_x_100)) {
             *min_slope_x_100 = (int)(slope*100);
@@ -428,12 +447,16 @@
     #endif
 
     /* Check pass/fail conditions */
+    /* Individual conditions checked above; just OR all the per-LED fails here */
     BOOLEAN passed = TRUE;
+    for (led = 0; led < N_LEDS; led++) {
+        *failing_led_cnt += led_fail[led];
+#ifdef VERBOSE
+        printf("LED %d: %s\r\n", (led+1), led_fail[led] ? "failed" : "passed");
+#endif
+        passed &= (led_fail[led] == 0);
+    }
 
-    passed  = (*max_current_err_pct > MAX_ERR_PCT) ? FALSE : TRUE;
-    passed &= (*min_peak_brightness_atwd > MIN_PEAK_MAX_BRIGHT);
-    passed &= (*min_slope_x_100 > (int)(MIN_SLOPE*100));
-    
     /* Free allocated structures */
     free(atwd_pedestal[3]);
     free(channels[3]);
