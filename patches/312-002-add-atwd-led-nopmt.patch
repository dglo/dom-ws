add atwd_led_nopmt test

diff --exclude=CVS -r -N -u -P ../tmp/stf/private/stf-apps/Makefile stf/private/stf-apps/Makefile
--- ../tmp/stf/private/stf-apps/Makefile	Fri Feb  4 01:11:39 2005
+++ stf/private/stf-apps/Makefile	Fri Mar  4 09:52:27 2005
@@ -26,7 +26,7 @@
 	atwd_clock1x_forced.o flasher_brightness.o flasher_width.o \
 	fadc_fe_pulser.o fadc_baseline.o fadc_fe_forced.o disc_scan.o \
 	loopback_lc.o atwd_pedestal_noise.o temperature.o atwd_pmt_spe.o \
-	fadc_fe_external.o atwd_pmt_led.o flasher_clock.o
+	fadc_fe_external.o atwd_pmt_led.o flasher_clock.o atwd_led_nopmt.o
 
 XMLFILES  = $(TESTOBJS:.o=.xml)
 CFILES    = $(TESTOBJS:.o=.c)
diff --exclude=CVS -r -N -u -P ../tmp/stf/private/stf-apps/atwd_led_nopmt.c stf/private/stf-apps/atwd_led_nopmt.c
--- ../tmp/stf/private/stf-apps/atwd_led_nopmt.c	Thu Jan  1 01:00:00 1970
+++ stf/private/stf-apps/atwd_led_nopmt.c	Fri Mar  4 09:48:52 2005
@@ -0,0 +1,185 @@
+/* atwd_led_nopmt.c, skeleton file created by George */
+
+#include <stdlib.h>
+#include <math.h>
+
+#include "stf/stf.h"
+#include "stf-apps/atwd_led_nopmt.h"
+
+#include "hal/DOM_MB_hal.h"
+#include "hal/DOM_MB_fpga.h"
+
+#include "stf-apps/atwdUtils.h"
+
+BOOLEAN atwd_led_nopmtInit(STF_DESCRIPTOR *d) {
+   return TRUE;
+}
+
+BOOLEAN atwd_led_nopmtEntry(STF_DESCRIPTOR *d,
+                    unsigned atwd_sampling_speed_dac,
+                    unsigned atwd_ramp_top_dac,
+                    unsigned atwd_ramp_bias_dac,
+                    unsigned atwd_analog_ref_dac,
+                    unsigned atwd_pedestal_dac,
+                    unsigned atwd_ch0_clamp,
+                    unsigned atwd_chip_a_or_b,
+		    unsigned LED_dac,
+                    unsigned atwd_mux_bias_dac,
+                    unsigned delay_in_ns,
+                    unsigned loop_count,
+                    unsigned n_pedestal_waveforms,
+                    BOOLEAN pedestal_subtraction,
+                    unsigned *real_LED_voltage,
+                    unsigned *LED_baseline_waveform,
+                    unsigned *LED_waveform_width,
+                    unsigned *LED_waveform_amplitude,
+                    unsigned *LED_waveform_position,
+                    unsigned * LED_waveform_pmtLED) {
+   const int ch = (atwd_chip_a_or_b) ? 0 : 4;
+   int i;
+   const int cnt = 128;
+   short *channels[4] = { NULL, NULL, NULL, NULL };
+   short *buffer1 = (short *) calloc(128, sizeof(short));
+   int *sum_waveform_LED = (int *) calloc(128, sizeof(int));
+   int trigger_mask = (atwd_chip_a_or_b) ? 
+      HAL_FPGA_TEST_TRIGGER_ATWD0 : HAL_FPGA_TEST_TRIGGER_ATWD1;
+   float real_delay = delay_in_ns/25.0 - 2;
+
+   /* pretest 1) all five atwd dac settings are programmed... */
+   halWriteDAC(ch, atwd_sampling_speed_dac);
+   halWriteDAC(ch+1, atwd_ramp_top_dac);
+   halWriteDAC(ch+2, atwd_ramp_bias_dac);
+   halWriteDAC(DOM_HAL_DAC_ATWD_ANALOG_REF, atwd_analog_ref_dac);
+   halWriteDAC(DOM_HAL_DAC_PMT_FE_PEDESTAL, atwd_pedestal_dac);
+   halWriteDAC(DOM_HAL_DAC_LED_BRIGHTNESS, LED_dac);
+   halWriteDAC(DOM_HAL_DAC_MUX_BIAS, atwd_mux_bias_dac);
+   /* FIXME: clamp? */
+
+   /* pretest 2) LED is off */
+   halDisableLEDPS();
+
+   /* pretest 3) Enable LED to get the noise */
+   hal_FPGA_TEST_enable_LED();
+   halSelectAnalogMuxInput(DOM_HAL_MUX_PMT_LED_CURRENT);
+   hal_FPGA_TEST_set_atwd_LED_delay((int) real_delay);
+
+   /* clear atwd */
+   prescanATWD(trigger_mask);
+
+   /* acquire pedestal baseline for LED*/
+   for (i=0; i<cnt; i++) sum_waveform_LED[i] = 0;
+   for (i=0; i<n_pedestal_waveforms; i++) {
+      int j;
+      hal_FPGA_TEST_trigger_LED(trigger_mask);      
+      channels[3] = buffer1;
+      hal_FPGA_TEST_readout(channels[0], channels[1], channels[2], 
+		            channels[3], 
+			    channels[0], channels[1], channels[2], 
+			    channels[3],
+			    cnt, NULL, 0, trigger_mask);
+      for (j=0; j<cnt; j++) {
+	sum_waveform_LED[j] += buffer1[j];
+      }
+   }
+   for (i=0; i<cnt; i++) {
+     sum_waveform_LED[i] /= n_pedestal_waveforms;
+   }
+
+   /* 2) set LED dac... */
+   halEnableLEDPS();
+   halUSleep(1000*2000);
+   *real_LED_voltage = (halReadADC(DOM_HAL_ADC_SINGLELED_HV)*17/1000);    /*LED voltage = ADC*2*(150+20)/20*(1/1000) */
+
+   /* wait for dacs, et al... */
+   halUSleep(1000*100);
+
+   /* 3) take loop_count waveforms...
+    */
+   for (i=0; i<cnt; i++) LED_waveform_pmtLED[i] = 0;
+   for (i=0; i<loop_count; i++) {
+      int j;
+      
+      hal_FPGA_TEST_trigger_LED(trigger_mask);      
+      channels[3] = buffer1;
+      hal_FPGA_TEST_readout(channels[0], channels[1], channels[2], 
+			    channels[3], 
+			    channels[0], channels[1], channels[2], 
+			    channels[3],
+			    cnt, NULL, 0, trigger_mask);
+      for (j=0; j<cnt; j++) {
+	LED_waveform_pmtLED[j] += buffer1[j];
+      }
+   }
+      
+      for (i=0; i<cnt; i++) {
+	LED_waveform_pmtLED[i] /= loop_count;
+      }
+
+   /* 6), 7) */
+   if (pedestal_subtraction) {
+      *LED_baseline_waveform = 100;
+      
+      for (i=0; i<cnt; i++) {
+	 const int v1 = (int) LED_waveform_pmtLED[i];
+	 const int v2 = (int) sum_waveform_LED[i];
+	 const int v_LED = v1 - v2 + 100;
+	 LED_waveform_pmtLED[i] = (v_LED<0) ? 0 : v_LED;
+      }
+   }
+   else {
+      *LED_baseline_waveform = 0;
+      for (i=0; i<cnt; i++) {
+	*LED_baseline_waveform += sum_waveform_LED[i];
+      }
+      *LED_baseline_waveform /= cnt;
+   }
+   
+   free(sum_waveform_LED);
+
+   /*turn off LED*/
+   halDisableLEDPS();
+
+   /* 8) reverse waveform */
+   reverseATWDIntWaveform(LED_waveform_pmtLED);
+     
+   /* 9) find max index */
+   {   int LED_maxIdx =0;
+       unsigned LED_maxValue = LED_waveform_pmtLED[LED_maxIdx];
+       int LED_half_max, LED_hmxIdx = 127, LED_hmnIdx = 0;
+       
+       for (i=1; i<128; i++) {
+	  if (LED_maxValue < LED_waveform_pmtLED[i]) {
+	     LED_maxIdx = i;
+	     LED_maxValue = LED_waveform_pmtLED[i];
+	  }
+       }
+
+       /* 10) */
+       *LED_waveform_amplitude = LED_maxValue - *LED_baseline_waveform;
+
+       /* 11) */
+       LED_half_max = 
+	 (*LED_waveform_amplitude)/2 + *LED_baseline_waveform;
+
+       for (i=LED_maxIdx; i<cnt; i++) {
+	  if (LED_waveform_pmtLED[i]<LED_half_max) {
+	     LED_hmxIdx = i;
+	     break;
+	  }
+       }
+       for (i=LED_maxIdx; i>=0; i--) {
+	  if (LED_waveform_pmtLED[i]<LED_half_max) {
+	     LED_hmnIdx = i;
+	     break;
+	  }
+       }
+
+       /* 14 */
+       *LED_waveform_width = LED_hmxIdx - LED_hmnIdx;
+       *LED_waveform_position = LED_maxIdx + 1;
+   }
+
+   free(buffer1);
+   return       
+     ((LED_dac==0 && *real_LED_voltage>=16 && *real_LED_voltage<=17) || (LED_dac==1023 && *real_LED_voltage>=0 && *real_LED_voltage<=3));
+}
diff --exclude=CVS -r -N -u -P ../tmp/stf/private/stf-apps/atwd_led_nopmt.xml stf/private/stf-apps/atwd_led_nopmt.xml
--- ../tmp/stf/private/stf-apps/atwd_led_nopmt.xml	Thu Jan  1 01:00:00 1970
+++ stf/private/stf-apps/atwd_led_nopmt.xml	Fri Mar  4 09:48:52 2005
@@ -0,0 +1,125 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<stf:test xmlns:stf="http://glacier.lbl.gov/icecube/daq/stf">
+  <name>atwd_led_nopmt</name>
+  <description>ATWD with LED Test, but without PMT on</description>
+  <version major="1" minor="0"/>
+
+  <fpgaDependencies>
+	<DAQ/>
+  </fpgaDependencies>
+
+  <inputParameter>
+    <description>DAC setting (of a 12 Bit device) for ATWD sampling speed</description>
+    <name>atwd_sampling_speed_dac</name>
+    <unsignedInt default="850" maxValue="4095" minValue="0"/>
+  </inputParameter>
+
+  <inputParameter>
+    <description>DAC setting (of a 12 Bit device) for ATWD Ramp Top Voltage</description>
+    <name>atwd_ramp_top_dac</name>
+    <unsignedInt default="2300" maxValue="4095" minValue="0"/>
+  </inputParameter>
+
+  <inputParameter>
+    <description>DAC setting (of a 12 Bit device) for ATWD Ramp Bias current </description>
+    <name>atwd_ramp_bias_dac</name>
+    <unsignedInt default="350" maxValue="4095" minValue="0"/>
+  </inputParameter>
+
+  <inputParameter>
+    <description>ATWD Analog Reference Voltage Input</description>
+    <name>atwd_analog_ref_dac</name>
+    <unsignedInt default="2250" maxValue="4095" minValue="0"/>
+  </inputParameter>
+
+  <inputParameter>
+    <description>DAC setting (of a 12 Bit device) for ATWD Pedestal Voltage</description>
+    <name>atwd_pedestal_dac</name>
+    <unsignedInt default="2130" maxValue="4095" minValue="0"/>
+  </inputParameter>
+
+  <inputParameter>
+    <description>DAC setting for ATWD 1st stage output clamping</description>
+    <name>atwd_ch0_clamp</name>
+    <unsignedInt default="0" maxValue="4095" minValue="0"/>
+  </inputParameter>
+
+  <inputParameter>
+    <description>Selects one of two chips (A or B) on the board:0=ATWD-A and 1=ATWD-B </description>
+    <name>atwd_chip_a_or_b</name>
+    <unsignedInt default="0" maxValue="1" minValue="0"/>
+  </inputParameter>
+
+  <inputParameter>
+    <description>LED DAC value </description>
+    <name>LED_dac</name>
+    <unsignedInt default="1023" minValue="0" maxValue="2047"/>
+  </inputParameter>
+
+  <inputParameter>
+    <description>MUX BIAS DAC value </description>
+    <name>atwd_mux_bias_dac</name>
+    <unsignedInt default="900" minValue="0" maxValue="1023"/>
+  </inputParameter>
+
+  <inputParameter>
+    <description>ATWD and LED delay in ns </description>
+    <name>delay_in_ns</name>
+    <unsignedInt default="50" minValue="26" maxValue="100000000"/>
+  </inputParameter>
+
+  <inputParameter>
+    <description>Number of SPE waveforms to collect and average</description>
+    <name>loop_count</name>
+    <unsignedInt default="1000" minValue="0" maxValue="1000000"/>
+  </inputParameter>
+
+  <inputParameter>
+    <description>Number of pedestal waveforms to acquire and average</description>
+    <name>n_pedestal_waveforms</name>
+    <unsignedInt default="50"/>
+  </inputParameter>
+
+  <inputParameter>
+    <description>Should we do pedestal subtraction?</description>
+    <name>pedestal_subtraction</name>
+    <boolean default="true"/>
+  </inputParameter>
+
+  <outputParameter>
+    <description>Actual LED output voltage</description>
+    <name>real_LED_voltage</name>
+    <unsignedInt/>
+  </outputParameter>
+
+  <outputParameter>
+    <description>Waveform of baseline for LED in ATWD counts units</description>
+    <name>LED_baseline_waveform</name>
+    <unsignedInt/>
+  </outputParameter>
+
+  <outputParameter>
+    <description>Width of the LED current waveform</description>
+    <name>LED_waveform_width</name>
+    <unsignedInt/>
+  </outputParameter>
+
+  <outputParameter>
+    <description>Amplitude of the LED current waveform</description>
+    <name>LED_waveform_amplitude</name>
+    <unsignedInt/>
+  </outputParameter>
+
+  <outputParameter>
+    <description>Pulse peak position in LED current samples units</description>
+    <name>LED_waveform_position</name>
+    <unsignedInt/>
+  </outputParameter>
+
+  <outputParameter>
+    <description>Average LED current waveform</description>
+    <name>LED_waveform_pmtLED</name>
+    <unsignedIntArray length="128"/>
+  </outputParameter>
+
+</stf:test>
diff --exclude=CVS -r -N -u -P ../tmp/stf/src/icecube/daq/stf/autogen/STFParameterLookup.java stf/src/icecube/daq/stf/autogen/STFParameterLookup.java
--- ../tmp/stf/src/icecube/daq/stf/autogen/STFParameterLookup.java	Fri Feb  4 01:13:50 2005
+++ stf/src/icecube/daq/stf/autogen/STFParameterLookup.java	Fri Mar  4 09:54:55 2005
@@ -1405,6 +1405,100 @@
     p.setType(STFParameterType.getType("unsignedInt"));
     hm.put("valid_time_us", p);
 
+    ret.put("atwd_led_nopmt", hm=new HashMap());
+    p = new STFParameter( true );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    p.setDefaultValue("850");
+    p.setMinValue("0");
+    p.setMaxValue("4095");
+    hm.put("atwd_sampling_speed_dac", p);
+    p = new STFParameter( true );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    p.setDefaultValue("2300");
+    p.setMinValue("0");
+    p.setMaxValue("4095");
+    hm.put("atwd_ramp_top_dac", p);
+    p = new STFParameter( true );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    p.setDefaultValue("350");
+    p.setMinValue("0");
+    p.setMaxValue("4095");
+    hm.put("atwd_ramp_bias_dac", p);
+    p = new STFParameter( true );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    p.setDefaultValue("2250");
+    p.setMinValue("0");
+    p.setMaxValue("4095");
+    hm.put("atwd_analog_ref_dac", p);
+    p = new STFParameter( true );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    p.setDefaultValue("2130");
+    p.setMinValue("0");
+    p.setMaxValue("4095");
+    hm.put("atwd_pedestal_dac", p);
+    p = new STFParameter( true );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    p.setDefaultValue("0");
+    p.setMinValue("0");
+    p.setMaxValue("4095");
+    hm.put("atwd_ch0_clamp", p);
+    p = new STFParameter( true );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    p.setDefaultValue("0");
+    p.setMinValue("0");
+    p.setMaxValue("1");
+    hm.put("atwd_chip_a_or_b", p);
+    p = new STFParameter( true );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    p.setDefaultValue("1023");
+    p.setMinValue("0");
+    p.setMaxValue("2047");
+    hm.put("LED_dac", p);
+    p = new STFParameter( true );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    p.setDefaultValue("900");
+    p.setMinValue("0");
+    p.setMaxValue("1023");
+    hm.put("atwd_mux_bias_dac", p);
+    p = new STFParameter( true );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    p.setDefaultValue("50");
+    p.setMinValue("26");
+    p.setMaxValue("100000000");
+    hm.put("delay_in_ns", p);
+    p = new STFParameter( true );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    p.setDefaultValue("1000");
+    p.setMinValue("0");
+    p.setMaxValue("1000000");
+    hm.put("loop_count", p);
+    p = new STFParameter( true );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    p.setDefaultValue("50");
+    hm.put("n_pedestal_waveforms", p);
+    p = new STFParameter( true );
+    p.setType(STFParameterType.getType("boolean"));
+    p.setDefaultValue("true");
+    hm.put("pedestal_subtraction", p);
+    p = new STFParameter( false );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    hm.put("real_LED_voltage", p);
+    p = new STFParameter( false );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    hm.put("LED_baseline_waveform", p);
+    p = new STFParameter( false );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    hm.put("LED_waveform_width", p);
+    p = new STFParameter( false );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    hm.put("LED_waveform_amplitude", p);
+    p = new STFParameter( false );
+    p.setType(STFParameterType.getType("unsignedInt"));
+    hm.put("LED_waveform_position", p);
+    p = new STFParameter( false );
+    p.setType(STFParameterType.getType("unsignedIntArray"));
+    hm.put("LED_waveform_pmtLED", p);
+
     ret.put("tcal", hm=new HashMap());
     p = new STFParameter( false );
     p.setType(STFParameterType.getType("unsignedInt"));
