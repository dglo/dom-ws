proposed packet format:

32 bit word aligned, data arranged in
little endian format...

|<------------ 32 bits ------------>|
|<--- 16 bits --->|<--- 16 bits --->|
| sequence number | type and length | <- start of packet
|                 .                 | 
|                 .                 |
|                 .                 |
|        length bytes of data       |
|                 .                 |
|                 .                 |
|                 .                 |
| pad2  |  pad1   | pad0  |  datan  |
|<------------ CRC 32 ------------->| <- last 32 bit word

total packet length in bytes =
	((length+3)/4) * 4 + 8

where:

sequence number:  

the (unsigned 16 bit) sequence number of the 
data packet sent or, if the packet is an acknowledge 
(ack) the sequence number of the packet that is
being acknowledged.  the sequence number is only
used in data and ack packets, other packet types
could use this field for other purposes, see
the type field description below for other uses
of this field by other packet types.

rationale: in order to do error correction in software, 
we need to keep track of the packet sequence number.
16 bits of sequence number allows us to look
forward or backware 32K packets, this is
far more than we are ever going to buffer, 
but the next byte aligned step down (8 bits)
only gives us +-128 of range which is currently
less that we're using now and so would not be
enough margin for a safe design.  a non-byte
aligned sequence number size would not allow
us to use a standard "C" type to hold the
value, hence all sequence number arithmetic
would require masks, a process that would be
error-prone and probably more complicated than
could be justified by the savings in bits
on the wire.

type and length:

|A |<-type->|<------------- length ------------->| 
|-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- |
|15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 |

where:

A (1 bit): dom A or B bit.

  the "A" bit allows us to determine whether this packet 
  was destined for the A dom (1) or the B dom(0).  in the 
  case of packets heading for the surface, this bit indicates 
  whether packets are sourced from the A dom or the B dom.

  rationale: tagging each packet with the destined
  dom may allow simplifications of the hardware
  design at a later state.  esp on the dor side,
  where it would allow the doms sharing a cable to also
  share a tx fifo -- hence, more effectively using
  the available fifo space...

type (3 bits): packet type.

  the packet type is (base 2):

    000: data packet in the beginning/middle of a sequence.
    001: acknowledgement of a data packet.
    010: data packet, at the end of a sequence.
    011: control packet.
    100: initiate connection
    101: connection initiated
    110: DOR control message
    111: undefined

  rationale: in order to support software error correction,
  we need the first 6 messages.  we use these as follows:

    000: data packet, no syn_fin.  this is a data packet that
         is not yet ready to be passed to the user.  it has
         another packet behind it with the rest of the data.
	 the sequence number field contains the sequence number
         of this data packet.  using this scheme we are able
         to translate "software" packets of any length to
	 "hardware" packets of a fixed maximum length.

    001: ack packet.  acknowledge a data packet.  the sequence
         number field describes the data packet that we are
         acknowledging.  no payload with this packet.

    010: data packet, syn_fin set.  this is a data packet that
         is complete and ready to ship to the user.  any previous
         packets with no syn_fin are prepended in order to this
         packet when shipping to the user.

    011: control packet.  this packet never makes it to the user
         but is used to communicate unreliably between the "kernel"
         communications agents.  we are currently using this type
         of packet to pass comm statistics from the dom to the dor. 

    100: initiate connection.  on startup, the dom and dor must
         negotiate sequence numbers.  this packet type allows us
         to signal that we want to start the negotiation.  there is
         no payload to this packet.

    101: connection initiated.  this packet type confirms to the
         other side of the comm link that we are alive and ready
         to start our tx and rx sequence numbers from zero.

    110: DOR control message.  this packet type allows DOR control
         messages to be added to the packets.  the control message
         data are put in the sequence number field of the packet, the
         only messages defined now are (from DOR API Rev 1.9):

             DOR packet types (low 8 bits of sequence number field):

                 0x01 time calibration packet
                 0x02 DOM ID packet

             DOR commands (high 8 bits of sequence number field):

                 0x0100 STF    start of frame
                 0x0200 EOF    end of frame
                 0x0300 IDREQ  dom id request
                 0x0400 UNDEF  undefined
                 0x0500 DRREQ  data read request
                 0x0600 DRAND  data read ack by dom, dom tx has no data
                 0x0700 DRBT   dom reboot -- 
                 0x0800 MRWB   message received, more Rx buffer avail
                 0x0900 MRNB   message received, no more Rx buffer avail
                 0x0a00 MRWE   message received, error detected
                 0x0b00 COMRES comm reset
                 0x0c00 BFSTAT DOM Rx Buffer status request
                 0x0d00 SYSRES DOM System Reset (softboot)
                 0x0e00 TCAL   start time calibration
                 0x0f00 IDLE   DOR idle, answered by DOM idle

    111: undefined.  left over type.

length (12 bits): data (payload) length in bytes

  this field allows us to know how big the data portion of
  the packet will be.  the actual packet length can be calculated
  from this number using the "C" code (integer math):

	packet length = ((length+3)/4) * 4 + 8

  rationale: this field is first in the header as hardware crc
  detection and creation would require the length of the data
  in order to work (and nothing else).  the 12 bits of packet
  length allow us up to 4095 byte packets (4104 bytes including
  header and crc).  at 4095 byte packets the header/crc overhead
  is about 1 part in 512.  this should be negligible overhead
  for the high speed data throughput mode.  keeping the length 
  reasonably small allows us to buffer less data on the dor and 
  dom side when using software error correction mode.

data ( ((length+3)/4) * 4 bytes ):

  this is the payload of the packet.  the data are organized in
  little endian.  and padding is added to the end of this field
  so that the data are a multiple of 4 bytes.

  rationale: 4 byte alignment allows the software to be greatly
  simplified and also allows us to use 32 bit dual ported memory
  in the dom side.  also, the pci bus core we're using on the dor
  side has a 32 bit bus, so data can be directly dropped into
  the packets.  also, 32 bit alignment allows us to drop in the
  32 bit crc more cleanly using firmware.  the overhead of average
  loss of 12 bits is not significant compared to the common packet
  sizes that we expect.

CRC (32 bits):

  this field is the 32 bit aligned CRC32.

  rationale: crc32 is commonly used to detect data transmission errors,
  32 bits gives us quite a bit of confidence in the packet integrity,
  and is relatively easy to calculate in firmware.














